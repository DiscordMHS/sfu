<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Unified Join Client (SendOnly Mic)</title>
  <style>
    body { font-family: monospace; max-width: 800px; margin: 2em auto; background: #f4f4f9; }
    .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    button { padding: 10px 20px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 16px; }
    button:disabled { background: #ccc; }
    #logs { background: #222; color: #0f0; padding: 10px; height: 300px; overflow-y: auto; border-radius: 4px; margin-top:10px;}
    .badge { background: #007bff; color: white; padding: 5px 10px; border-radius: 15px; margin: 5px; display: inline-block; }
  </style>
</head>
<body>

<div class="container">
  <h1>ðŸš€ Unified Join Client (Fixed)</h1>
  <p>1. Local Mic: <b>sendonly</b>.<br>2. Remote Tracks: Accepted via Server Offer -> Updated Answer.</p>

  <div style="margin-bottom: 20px;">
    <input id="wsurl" value="ws://127.0.0.1:8000" placeholder="WS URL">
    <input id="roomid" value="1001" size="5" placeholder="Room">
    <button id="connect">Get Mic & Join</button>
  </div>
  
  <div id="remotes"></div>
  <pre id="logs"></pre>
</div>

<script>
let pc, ws;

function log(msg) {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    console.log(line);
    document.getElementById("logs").textContent += line + "\n";
    document.getElementById("logs").scrollTop = 99999;
}

document.getElementById("connect").onclick = async () => {
  const url = document.getElementById("wsurl").value;
  document.getElementById("connect").disabled = true;

  try {
      // 1. Get Microphone
      log("ðŸŽ¤ Requesting Microphone...");
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      log("âœ… Microphone Acquired.");

      startConnection(url, stream);

  } catch (e) {
      log("âŒ Error: " + e.message);
      document.getElementById("connect").disabled = false;
  }
};

function startConnection(url, localStream) {
  ws = new WebSocket(url);

  ws.onopen = () => {
    log("ðŸ”µ WebSocket Connected");
    
    pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    // --- STEP A: Add Mic Track as SENDONLY ---
    localStream.getTracks().forEach(track => {
        pc.addTransceiver(track, {
            direction: 'sendonly', 
            streams: [localStream]
        });
        log(`âž• Added Local Mic (sendonly)`);
    });

    // --- STEP B: Prepare to Play Incoming Audio ---
    pc.ontrack = (e) => {
        const id = e.track.id;
        log(`ðŸŽ§ RECEIVED TRACK (User: ${id.substring(0,5)}...)`);
        
        const badge = document.createElement('div');
        badge.className = 'badge';
        badge.innerHTML = `Track ${id.substring(0,5)}... ðŸ”Š`;
        
        const au = document.createElement('audio');
        au.srcObject = e.streams[0];
        au.autoplay = true;
        badge.appendChild(au);
        document.getElementById("remotes").appendChild(badge);
    };

    // --- STEP C: Send Initial "Join" Offer ---
    pc.onnegotiationneeded = async () => {
        log("âš™ï¸ Negotiating Local Mic...");
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({
            type: "offer",
            room_id: document.getElementById("roomid").value,
            sdp: pc.localDescription.sdp
        }));
    };

    pc.onicecandidate = ({candidate}) => {
        if (candidate) ws.send(JSON.stringify({ type: "candidate", candidate: candidate.candidate, sdpMid: candidate.sdpMid }));
    };
  };

  ws.onmessage = async (msg) => {
    const data = JSON.parse(msg.data);

    if (data.type === "answer") {
      log("ðŸ“© Recv ANSWER: Mic upload accepted.");
      await pc.setRemoteDescription(data);
    } 
    else if (data.type === "offer") {
      // --- STEP D: Handle Server Offer (New Tracks) ---
      log("ðŸ“© Recv SERVER OFFER: Processing incoming tracks...");

      // 1. Accept the Server's Offer
      await pc.setRemoteDescription(data);

      // 2. Generate Answer
      let answer = await pc.createAnswer();

      // DEBUG: Verify tracks are in the Answer
      pc.getTransceivers().forEach((t, i) => {
          if (t.direction === 'recvonly') {
              log(`   ðŸ‘‰ Answer includes RecvOnly track for Mid:${t.mid}`);
          }
      });

      // --- FIX START: Patch Incompatible Roles ---
      // Fixes "uncaught exception: Incompatible roles with remote description"
      // Firefox may mix active/passive roles in a Bundle. We force uniformity.
      let sdp = answer.sdp;
      if (sdp.includes("a=setup:passive")) {
          if (sdp.includes("a=setup:active")) {
             log("ðŸ”§ Patching SDP: Replacing 'active' roles with 'passive' to ensure bundle consistency.");
             sdp = sdp.replace(/a=setup:active/g, "a=setup:passive");
          }
      }
      
      const fixedAnswer = { type: answer.type, sdp: sdp };
      // --- FIX END ---

      await pc.setLocalDescription(fixedAnswer);

      // 3. Send Answer back (Using the fixed SDP)
      ws.send(JSON.stringify(fixedAnswer));
      log("ðŸ“¤ Sent Answer matching Server tracks.");
    } 
    else if (data.type === "candidate") {
      if (pc.remoteDescription) await pc.addIceCandidate(data);
    }
  };
}
</script>
</body>
</html>
